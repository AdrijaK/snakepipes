---
title: "WGBS_QC_report"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
.libPaths(R.home("library"))
require(pander)
require(ggplot2)
```

# Conversion rate

Commercial bisulfite conversion kits claim an efficiency of >98%. In practice, the expected conversion rate can be taken as >95%.
Incomplete bisulfite conversion will result in uninterpretable methylation values.
Bisulfite conversion rate is calculated on cytosines in a CHH context.

```{r echo=FALSE, message=FALSE, warning=FALSE}
if (length(snakemake@input[["ConversionRate"]] > 0)) {
    d = sapply(snakemake@input[["ConversionRate"]], function(x) read.table(x, header=FALSE, sep="\t", quote="", as.is=TRUE))
    d = as.data.frame(t(d), stringsAsFactors=FALSE)
    rownames(d) = d$V1
    colnames(d) = c("Sample", "Conversion Rate (%)")
    d = d[, 2, drop=FALSE]
    pander(d, style='simple')
} else {
    message('No conversion rate output files found!')
}
```

# Mapping rate

A good mapping rate of 80-90% indicates successful library construction. Low mapping rates may reflect issues with sample contamination, damaged starting material, or that you aligned a non-directional library with directional settings. "Filtered" alignments are due to less than 44% of the the read sequence being aligned (i.e., the alignment is likely incorrect and is thus being ignored).

```{r echo=FALSE, message=FALSE, warning=FALSE}
if (length(snakemake@input[["fstat"]] > 0)) {
    fl = lapply(snakemake@input[["fstat"]], function(x) read.table(x, header=FALSE, sep="\t", quote="", as.is=TRUE))
    totals = sapply(fl, function(x) {
        v = strsplit(x$V1[1], " ")[[1]]
        as.numeric(v[1]) + as.numeric(v[3])
    })
    mapped = sapply(fl, function(x) {
        v = strsplit(x$V1[5], " ")[[1]]
        as.numeric(v[1]) + as.numeric(v[3])
    })
    filtered = totals - sapply(fl, function(x) {
        v = strsplit(x$V1[5], " ")[[1]]
        v2 = strsplit(x$V1[5], " ")[[1]]
        as.numeric(v[1])
    })
    d = data.frame(Total=totals,
                   Mapped=mapped,
                   MappedPercent=100*mapped/totals,
                   Filtered=filtered,
                   FilteredPercent=100*filtered/totals)
    rownames(d) = gsub(".flagstat", "", sapply(snakemake@input[["fstat"]], basename))
    pander(d, style='simple')
} else {
    message('No flagstat files found!')
}
```

# PCR duplication rate

Observed PCR duplication rate on a PCR-free protocol should be low, not exceeding 10-15%. Higher duplication rates might reflect low-input samples and/or lower library complexity.

```{r echo=FALSE, message=FALSE, warning=FALSE}
if (length(snakemake@input[["fstat"]] > 0)) {
    fl = lapply(snakemake@input[["fstat"]], function(x) read.table(x, header=FALSE, sep="\t", quote="", as.is=TRUE))
    totals = sapply(fl, function(x) {
        v = strsplit(x$V1[1], " ")[[1]]
        as.numeric(v[1]) + as.numeric(v[3])
    })
    dupes = sapply(fl, function(x) {
        v = strsplit(x$V1[4], " ")[[1]]
        as.numeric(v[1]) + as.numeric(v[3])
    })
    d = data.frame(Duplicates=dupes,
                   DuplicationRate=100 * dupes/totals)
    rownames(d) = gsub(".flagstat", "", sapply(snakemake@input[["fstat"]], basename))
    pander(d, style='simple')
} else {
    message('No information on PCR duplicate removal found. If you started the pipeline from bam files, this is expected outcome. Otherwise, an error might have occurred.')
}
```

# Genome-wide coverage

Genome-wide coverage is calculated with deepTools plotCoverage. Note that mean coverage values should be intrepreted in the context of the skewness in the plot below. The table indicates the mean, standard deviation, minimum, median and maximum coverage of randomly sampled bins in the genome. Additionally, the 25, 50 (median) and 75% coverage value is indicated.

```{r echo=FALSE, warning=FALSE, message=FALSE}
# TODO: replace with deepTools
if(length(snakemake@input[["Coverage"]])) {
    infile = snakemake@input[["Coverage"]][1]
    d = read.delim(infile, as.is=TRUE)
    rownames(d) = gsub(".PCRrm", "", rownames(d))
    d = d[,c(1:(ncol(d)-1))]
    colnames(d) = c("Mean", "Std. Dev.", "Min.", "25%", "Median", "75%", "Max.")
    pander(d, style='simple')
} else {
    message('No information on genome-wide depth of coverage found. If you specified the skipDOC flag, this is expected outcome. Otherwise, an error might have occuarred.')
}
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
if(length(snakemake@input[["Coverage"]])) {
    knitr::include_graphics(sprintf("%s/%s", getwd(), snakemake@input[["Coverage"]][2]))
}
```

# CpG dinucleotide coverage

Fraction of CpG dinucleotides covered by reads with MAPQ >=5, using a random sampling of 1 million CpGs.

```{r echo=FALSE, warning=FALSE, message=FALSE}
# TODO: replace with deepTools once the new release is out.
if(length(snakemake@input[["Coverage"]])) {
    # CpG metrics are the first half and Genomic the second
    L = length(snakemake@input[["Coverage"]])
    infiles = snakemake@input[["Coverage"]][3:L]

    fl = lapply(infiles, read.delim)
    names(fl) = gsub(".doc.sample_summary", "", sapply(snakemake@input[["Coverage"]][3:L], basename))
    d = data.frame(AverageDepth=sapply(fl, function(x) x$readCount))
    row.names(d) = names(fl)
    pander(d, style='simple')
} else {
    message('No information on genome-wide depth of coverage found. If you specified the skipDOC flag, this is expected outcome. Otherwise, an error might have occuarred.')
}
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
if(length(snakemake@input[["Coverage"]])) {
    # Make some plots
    v = lapply(fl, function(x) {
        # Convert the percentageX headers to X values
        X = colnames(x)[2:ncol(x)]
        X = as.numeric(gsub("percentage", "", X))
        Y = unlist(x)[2:ncol(x)]
        data.frame(X=X, Y=Y)
        })
    v = as.data.frame(do.call(rbind, v))
    v$Sample = rep(names(fl), each=ncol(fl[[1]])-1)

    g = ggplot(v, aes(x=X, y=Y, color=Sample)) + geom_line()
    g = g + labs(x="Fold Coverage", y="Percentage of CpGs")
    g
}
```

# Methylation bias

Library construction of standard directional BS-Seq samples often consist of several steps including sonication, end-repair, A-tailing and adapter ligation. Since the end-repair step typically uses unmethylated cytosines for the fill-in reaction the filled-in bases will generally appear unmethylated after bisulfite conversion irrespective of their true genomic methylation state. (from sequencing.qcfail.com)
Values are obtained via MethylDackel.

```{r echo=FALSE, warning=FALSE, message=FALSE}
# TODO: pandoc is turning -- into an emdash/endash
if(length(snakemake@input[["mbiasTXT"]])) {
    fl = lapply(snakemake@input[["mbiasTXT"]], function(x) read.table(x, header=FALSE, sep="\t"))
    bounds = sapply(fl, function(x) gsub("Suggested inclusion options: ", "", x$V1, fixed=T))
    tab = data.frame("Trimming Bounds" = bounds)
    sampleNames = gsub(".Mbias.txt", "", basename(snakemake@input[["mbiasTXT"]]))
    rownames(tab) = sampleNames
    colnames(tab) = "Trimming Bounds"
    pander(tab, style='simple')
} else {
    message('No methylation bias files!')
}
```
