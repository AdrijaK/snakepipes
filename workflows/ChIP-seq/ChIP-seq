#!/usr/bin/env python3

__version__ = "0.1.0"

__description__ = """
ChIP-seq workflow v{version} - MPI-IE workflow for ChIP-seq analysis
Fabian Kilpert, Andreas Richter
June 9, 2016

Usage example:
    ChIP-seq
""".format(version=__version__)


import argparse
import os
import signal
import subprocess
import sys
import textwrap
import time


def parse_args():
    """
    Parse arguments from the command line.
    """

    parser = argparse.ArgumentParser(
    prog=sys.argv[0],
    formatter_class=argparse.RawDescriptionHelpFormatter, description=textwrap.dedent(__description__))

    ## optional
    parser.add_argument("-g", "--genome", dest="genome", required=True, help="genome acronym of target organism (e.g. mm10)")
    parser.add_argument("-c", "--configfile", dest="configfile", required=True, help="configuration file (config.yaml)", default=None)
    parser.add_argument("-i", "--input-dir", dest="indir", help="input dir containing (FASTQ)", default=None)
    parser.add_argument("-o", "--output-dir", dest="outdir", help="output directory", default=None)
    parser.add_argument("-j", "--jobs", dest="max_jobs", metavar="INT", help="maximum number of concurrently submitted grid engine jobs (default: '%(default)s')", type=int, default=999)
    parser.add_argument("-r", "--rerun-incomplete", dest="rerun_incomplete", action="store_true", default=False, help="rerun incomplete files only")
    parser.add_argument("-F", "--forceall", dest="forceall", action="store_true", default=False, help="Force rerun")
    parser.add_argument("--downsample", dest="downsample", metavar="INT", help="downsample reads from the head of each FASTQ file", default=None)
    parser.add_argument("--trim", dest="trim", action="store_true", default=False, help="Trim with TrimGalore")
    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true", default=False, help="verbose output")

    ## positional
    ## None

    args = parser.parse_args()

    ## Variable sanity checking
    ## None

    ## correction to variables
    try:
        args.indir = os.path.abspath(args.indir)
    except:
        args.indir = os.path.abspath(os.getcwd())

    try:
        args.outdir = os.path.abspath(args.outdir)
    except:
        args.outdir = os.path.abspath(os.getcwd())

    try:
        args.configfile = os.path.abspath(args.configfile)
    except:
        args.configfile = None

    try:
        args.downsample = int(args.downsample)
    except:
        args.downsample = None

    return args


def main():
    args = parse_args()

    ## Require shared biosnake directory
    this_script_dir = os.path.dirname(os.path.realpath(__file__))

    main_dir_path = os.path.join(os.path.dirname(os.path.dirname(this_script_dir)))
    if not os.path.isdir(main_dir_path):
        print("Error! Shared biosnake directory NOT available at:", main_dir_path)
        exit(1)

    ## Output directory + log directory
    cluster_logs_dir = os.path.join(args.outdir, "cluster_logs")
    subprocess.call("[ -d {cluster_logs_dir} ] || mkdir -p {cluster_logs_dir}".format(cluster_logs_dir=cluster_logs_dir), shell=True)

    ## requred
    user_configs = "--config maindir={main_dir_path} indir={indir} genome={genome}".format(
                                main_dir_path=main_dir_path,
                                indir=args.indir,
                                genome=args.genome).split()
    ## optional
    if args.downsample:
        user_configs += ["downsample={}".format(args.downsample)]
    if args.trim:
        user_configs += ["trim=True"]

    snakemake_module_load = "module load snakemake &&".split()
    snakemake_cmd = """
                    snakemake {user_configs} -p --directory {outdir} --snakefile {snakefile} --cluster 'SlurmEasy --threads {threads} --log {cluster_logs_dir}' --jobs {max_jobs} --jobname '{{rulename}}.{{jobid}}.snakejob'
                    """.format( user_configs=" ".join(user_configs),
                                snakefile=os.path.join(this_script_dir, "Snakefile"),
                                max_jobs=args.max_jobs,
                                indir=args.indir,
                                outdir=args.outdir,
                                cluster_logs_dir=os.path.abspath(cluster_logs_dir),
                                genome=args.genome,
                                main_dir_path=main_dir_path,
                                configfile=args.configfile).split()

    if args.configfile:
        snakemake_cmd += ["--configfile", args.configfile]

    snakemake_log = "2>&1 | tee -a {}/LOG".format(args.outdir).split()

    ## Add additional parameters if available
    # if args.downsample:
    #     snakemake_cmd.insert(2, "downsample={}".format(args.downsample))
    # if args.trim:
    #     snakemake_cmd.insert(2, "trim=True")
    if args.rerun_incomplete:
        snakemake_cmd.append("--rerun-incomplete")
    if args.forceall:
        snakemake_cmd.append("--forceall")

    cmd = " ".join(snakemake_module_load + snakemake_cmd + snakemake_log)

    if args.verbose:
        print("\n", cmd, "\n")

    ## Write snakemake_cmd to log file
    with open(os.path.join(args.outdir,"LOG"),"w") as f:
        f.write(" ".join(sys.argv)+"\n\n")
        f.write(cmd+"\n\n")

    ## Run snakemake
    p = subprocess.Popen(cmd, shell=True)
    if args.verbose:
        print("PID:", p.pid, "\n")
    try:
        p.wait()
    except:
        print("\nWarning: Snakemake terminated!!!")
        if p.returncode != 0:
            if p.returncode:
                print("Returncode:", p.returncode)

            # kill snakemake and child processes
            subprocess.call(["pkill", "-SIGTERM", "-P", str(p.pid)])
            print("SIGTERM sent to PID:", p.pid)

            # # kill grid engine jobs
            # time.sleep(10)
            # job_ids = subprocess.check_output("""ls {cluster_logs_dir} | awk -F "." '{{print $NF}}' | sed 's/e\|o//' | sort -u""".format(cluster_logs_dir=cluster_logs_dir), shell=True).split()
            # for job_id in job_ids:
            #     subprocess.call( "qdel {} 2>&1 >/dev/null".format(str(job_id)), shell="bash" )


if __name__ == "__main__":
    #print "Args:", sys.argv
    main()
